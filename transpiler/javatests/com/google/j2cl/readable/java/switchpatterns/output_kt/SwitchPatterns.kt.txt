// Generated from "switchpatterns/SwitchPatterns.java"
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "INCOMPATIBLE_OBJC_NAME_OVERRIDE",
 "REDUNDANT_ELSE_IN_WHEN",
 "ACCIDENTAL_OVERRIDE")

package switchpatterns

import javaemul.lang.*
import java.lang.AssertionError
import java.util.Arrays
import jsinterop.annotations.JsEnum
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Number
import kotlin.String
import kotlin.Suppress
import kotlin.arrayOf
import kotlin.jvm.JvmStatic
import kotlin.run
import switchpatterns.SwitchPatterns.Sealed.A
import switchpatterns.SwitchPatterns.Sealed.B

open class SwitchPatterns {
 internal open fun testPatternsWithGuards_pp_switchpatterns() {
  val o: Any = "Hello"
  var s: String? = null
  var j: Int? = null
  var j_1: Int? = null
  when (o) {
   is String if run {
    s = o as String?
    true
   } && s!!.length == 1 -> {}
   is String if run {
    val s_1: String? = o as String?
    true
   } -> {}
   else -> {}
  }
  val i: Int? = null
  when (i!!) {
   23, 32 -> {}
   is Int if run {
    j = i as Int?
    true
   } && j!!.toInt() > 2 -> {}
   is Number if run {
    val n: Number? = i as Number?
    true
   } -> {}
   else -> {}
  }
  when (i) {
   23, 32 -> {}
   is Int if run {
    j_1 = i as Int?
    true
   } && j_1!!.toInt() > 2 -> {}
   null -> {}
   else -> {}
  }
 }

 internal open fun testRecordPatterns_pp_switchpatterns() {
  class R {
   private val o: Any?

   private val s: String?

   constructor(arg0: Any?, arg1: String?) {
    this.o = arg0
    this.s = arg1
   }

   fun o(): Any? {
    return this.o
   }

   fun s(): String? {
    return this.s
   }

   override fun equals(arg0: Any?): Boolean {
    var ___other: R? = null
    if (!(arg0 is R && run {
     ___other = arg0 as R?
     true
    })) return false
    return Arrays.equals(
     arrayOf<Any?>(this.o, this.s),
     arrayOf<Any?>(___other!!.o, ___other!!.s),
    )
   }

   override fun hashCode(): Int {
    return Arrays.hashCode(
     arrayOf<Any?>(this.o, this.s),
    )
   }

   override fun toString(): String {
    return Arrays.toString(
     arrayOf<Any?>(this.o, this.s),
    )
   }
  }
  val r: Any? = null
  var pattern___1R: R? = null
  var pattern___1R_1: R? = null
  var s1: String? = null
  var s2: String? = null
  var pattern___1R_2: R? = null
  when (r!!) {
   is R if run {
    pattern___1R = r as R?
    true
   } && (run {
    val exp: Any? = pattern___1R!!.o()
    exp is R && run {
     pattern___1R_1 = exp as R?
     true
    }
   } && run {
    val exp_1: Any? = pattern___1R_1!!.o()
    exp_1 is String && run {
     s1 = exp_1 as String?
     true
    }
   } && run {
    s2 = pattern___1R_1!!.s()
    true
   }) && run {
    val s3: String? = pattern___1R!!.s()
    true
   } && s1!!.equals("Hello") -> {
    s2!!.length
   }
   is R if run {
    pattern___1R_2 = r as R?
    true
   } && run {
    val c1: Any? = pattern___1R_2!!.o()
    true
   } && run {
    val c2: String? = pattern___1R_2!!.s()
    true
   } -> {}
   else -> {}
  }
 }

 internal open fun testExhaustivePatternsWithNoDefault_pp_switchpatterns() {
  val o: Sealed? = null
  val i: Int = run {
   when (o!!) {
    is A if run {
     val a: A? = o as A?
     true
    } -> {
     return@run 1
    }
    is B if run {
     val b: B? = o as B?
     true
    } -> {
     return@run 2
    }
    else -> {
     throw AssertionError("Unreachable")
    }
   }
  }
 }

 internal open fun testPatternsWithNull_pp_switchpatterns() {
  val color: Color? = null
  when (color) {
   Color.RED -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   null -> {}
   else -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
  }
  when (color) {
   Color.RED -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   else -> {
    val variable: Int = 0
   }
  }
  when (Color.valueOf("BLUE")) {
   Color.RED -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   else -> {}
  }
  val digit: Digit? = null
  when (digit) {
   Digit.ZERO -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   null -> {}
   else -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
  }
  val s: String = "Hi"
  when (s) {
   "Hi" -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   null -> {}
   else -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
  }
  when (s) {
   "Hi" -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   else -> {}
  }
 }

 companion object {
  @JvmStatic
  internal fun fail_pp_switchpatterns() {}
 }

 interface Sealed {
  class A: Sealed

  class B: Sealed
 }

 enum class Color {
  RED,
  BLUE,
  GREEN;
 }

 @JsEnum
 enum class Digit {
  ZERO,
  ONE,
  TWO,
  THREE;
 }
}
