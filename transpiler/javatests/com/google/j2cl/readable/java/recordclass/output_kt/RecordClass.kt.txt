// Generated from "recordclass/RecordClass.java"
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "INCOMPATIBLE_OBJC_NAME_OVERRIDE",
 "REDUNDANT_ELSE_IN_WHEN",
 "ACCIDENTAL_OVERRIDE")

package recordclass

import javaemul.lang.*
import java.lang.Record
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.IntArray
import kotlin.String
import kotlin.Suppress
import kotlin.intArrayOf
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic

open class RecordClass {
 open fun main() {
  val r: SimpleRecord = SimpleRecord(1)
  r.value()
  val ar: ArrayRecord = ArrayRecord(
   intArrayOf(1, 2),
  )
  val arValueResult: Int = ar.value()!![0]
  val rwc: RecordWithConstructor = RecordWithConstructor(1, 2)
  rwc.a()
  rwc.b()
 }

 companion object {
  @JvmStatic
  private fun testLocalRecordClas() {
   class LocalRecord internal constructor(): Record() {
    private val value: Int
   }
   val lr: LocalRecord = LocalRecord(1)
  }
 }

 class SimpleRecord internal constructor(): Record() {
  private val value: Int
 }

 class StringRecord internal constructor(): Record() {
  private val value: String?
 }

 class ArrayRecord internal constructor(): Record() {
  private val value: IntArray?
 }

 class ObjectRecord internal constructor(): Record() {
  private val value: Any?
 }

 class RecordWithConstructor: Record {
  private val a: Int

  private val b: Int

  constructor(a: Int, b: Int) {
   this.a = a + 1
   this.b = b - 1
  }
 }

 class RecordWithCompactConstructor: Record {
  private val a: Int

  private val b: Int

  constructor(a: Int, b: Int) {
   var a_1: Int = a
   if (a_1 < 0) {
    a_1 = 0
   }
  }
 }

 class RecordWithDeferringConstructor: Record {
  private val value: Int

  constructor(): this(123)
 }

 class RecordWithOverriddenObjectMethods: Record() {
  private val value: String?

  override fun equals(other: Any?): Boolean {
   return false
  }

  override fun hashCode(): Int {
   return 0
  }

  override fun toString(): String {
   return "foo"
  }
 }

 class RecordWithOverriddenAccessor: Record() {
  private val value: String?

  fun value(): String? {
   return "foo"
  }
 }

 fun interface I {
  fun a(): String?
 }

 class RecordImplementingInterface internal constructor(): Record(), I {
  private val a: String?
 }

 class StaticFieldRecord: Record {
  private val nonstaticField: Int

  constructor(initializeWithStaticField: Boolean): this(
   if (initializeWithStaticField) StaticFieldRecord.staticField else 0,
  )

  companion object {
   @JvmField
   var staticField: Int = 1
  }
 }

 interface PropertyAccessors<T> {
  fun parametric(): T

  fun nonParametric(): String?
 }

 class RecordSpecializingInterface internal constructor(): Record(), PropertyAccessors<String?> {
  private val parametric: String?

  private val nonParametric: String?
 }
}
