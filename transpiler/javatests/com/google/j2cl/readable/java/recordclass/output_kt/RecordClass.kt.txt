// Generated from "recordclass/RecordClass.java"
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "INCOMPATIBLE_OBJC_NAME_OVERRIDE",
 "REDUNDANT_ELSE_IN_WHEN",
 "ACCIDENTAL_OVERRIDE")

package recordclass

import javaemul.lang.*
import java.lang.Record
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.IntArray
import kotlin.String
import kotlin.Suppress
import kotlin.intArrayOf
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import kotlin.run

open class RecordClass {
 open fun main() {
  val r: SimpleRecord = SimpleRecord(1)
  r.value()
  val ar: ArrayRecord = ArrayRecord(
   intArrayOf(1, 2),
  )
  val arValueResult: Int = ar.value()!![0]
  val rwc: RecordWithConstructor = RecordWithConstructor(1, 2)
  rwc.a()
  rwc.b()
 }

 companion object {
  @JvmStatic
  private fun testLocalRecordClas() {
   class LocalRecord internal constructor(): Record() {
    private val value: Int
   }
   val lr: LocalRecord = LocalRecord(1)
  }

  @JvmStatic
  private fun testRecordPatterns() {
   class R2 internal constructor(): Record() {
    private val i: Int

    private val o: Any?
   }
   class R1 internal constructor(): Record() {
    private val o: Any?

    private val s: String?

    private val n: R2?
   }
   val r: R1 = R1(
    R2(1, "a"),
    "b",
    R2(3, "c"),
   )
   var pattern___1R1: R1? = null
   var pattern___1R2: R2? = null
   var pattern___1R1_1: R1? = null
   var pattern___1R2_1: R2? = null
   val b: Boolean = r is R1 && run {
    pattern___1R1 = (r)
    true
   } && (run {
    val exp: Any? = pattern___1R1!!.o()
    exp is R2 && run {
     pattern___1R2 = (exp)
     true
    }
   } && run {
    val i1: Int = pattern___1R2!!.i()
    true
   } && run {
    val exp_1: Any? = pattern___1R2!!.o()
    exp_1 is String && run {
     val s1: String? = exp_1
     true
    }
   }) && run {
    val s2: Any? = pattern___1R1!!.s()
    true
   } && run {
    val n: R2? = pattern___1R1!!.n()
    true
   }
   val o: Any = R1(
    R2(1, "a"),
    "b",
    R2(3, "c"),
   )
   val b1: Boolean = o is R1 && run {
    pattern___1R1_1 = (o)
    true
   } && (run {
    val exp_2: Any? = pattern___1R1_1!!.o()
    exp_2 is R2 && run {
     pattern___1R2_1 = (exp_2)
     true
    }
   } && run {
    val i1_1: Int = pattern___1R2_1!!.i()
    true
   } && run {
    val exp_3: Any? = pattern___1R2_1!!.o()
    exp_3 is String && run {
     val s1_1: String? = exp_3
     true
    }
   }) && run {
    val s2_1: Any? = pattern___1R1_1!!.s()
    true
   } && run {
    val n_1: R2? = pattern___1R1_1!!.n()
    true
   }
  }
 }

 class SimpleRecord internal constructor(): Record() {
  private val value: Int
 }

 class StringRecord internal constructor(): Record() {
  private val value: String?
 }

 class ArrayRecord internal constructor(): Record() {
  private val value: IntArray?
 }

 class ObjectRecord internal constructor(): Record() {
  private val value: Any?
 }

 class RecordWithConstructor: Record {
  private val a: Int

  private val b: Int

  constructor(a: Int, b: Int) {
   this.a = a + 1
   this.b = b - 1
  }
 }

 class RecordWithCompactConstructor: Record {
  private val a: Int

  private val b: Int

  constructor(a: Int, b: Int) {
   var a_1: Int = a
   if (a_1 < 0) {
    a_1 = 0
   }
  }
 }

 class RecordWithDeferringConstructor: Record {
  private val value: Int

  constructor(): this(123)
 }

 class RecordWithOverriddenObjectMethods: Record() {
  private val value: String?

  override fun equals(other: Any?): Boolean {
   return false
  }

  override fun hashCode(): Int {
   return 0
  }

  override fun toString(): String {
   return "foo"
  }
 }

 class RecordWithOverriddenAccessor: Record() {
  private val value: String?

  fun value(): String? {
   return "foo"
  }
 }

 fun interface I {
  fun a(): String?
 }

 class RecordImplementingInterface internal constructor(): Record(), I {
  private val a: String?
 }

 class StaticFieldRecord: Record {
  private val nonstaticField: Int

  constructor(initializeWithStaticField: Boolean): this(
   if (initializeWithStaticField) StaticFieldRecord.staticField else 0,
  )

  companion object {
   @JvmField
   var staticField: Int = 1
  }
 }

 interface PropertyAccessors<T> {
  fun parametric(): T

  fun nonParametric(): String?
 }

 class RecordSpecializingInterface internal constructor(): Record(), PropertyAccessors<String?> {
  private val parametric: String?

  private val nonParametric: String?
 }
}
