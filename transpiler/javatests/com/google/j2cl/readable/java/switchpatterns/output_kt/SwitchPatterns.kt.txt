// Generated from "switchpatterns/SwitchPatterns.java"
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "INCOMPATIBLE_OBJC_NAME_OVERRIDE",
 "REDUNDANT_ELSE_IN_WHEN",
 "ACCIDENTAL_OVERRIDE")

package switchpatterns

import javaemul.lang.*
import java.lang.AssertionError
import java.util.Arrays
import jsinterop.annotations.JsEnum
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Number
import kotlin.String
import kotlin.Suppress
import kotlin.arrayOf
import kotlin.jvm.JvmStatic
import kotlin.run
import switchpatterns.SwitchPatterns.Sealed.A
import switchpatterns.SwitchPatterns.Sealed.B

open class SwitchPatterns {
 internal open fun testPatternsWithGuards_pp_switchpatterns() {
  val o: Any = "Hello"
  when (o) {
   is String if run {
    val s: String = o as String
    s.length == 1
   } -> {}
   is String if run {
    val s_1: String = o as String
    true
   } -> {}
   else -> {}
  }
  val i: Int? = null
  when (i!!) {
   23, 32 -> {}
   is Int if run {
    val j: Int? = i as Int
    j!!.toInt() > 2
   } -> {}
   is Number if run {
    val n: Number = i as Number
    true
   } -> {}
   else -> {}
  }
  when (i) {
   23, 32 -> {}
   is Int if run {
    val j_1: Int? = i as Int
    j_1!!.toInt() > 2
   } -> {}
   null -> {}
   else -> {}
  }
 }

 internal open fun testRecordPatterns_pp_switchpatterns() {
  class R {
   private val o: Any?

   private val s: String?

   constructor(arg0: Any?, arg1: String?) {
    this.o = arg0
    this.s = arg1
   }

   fun o(): Any? {
    return this.o
   }

   fun s(): String? {
    return this.s
   }

   override fun equals(arg0: Any?): Boolean {
    var ___other: R? = null
    if (!(arg0 is R && run {
     ___other = arg0 as R
     true
    })) return false
    return Arrays.equals(
     arrayOf<Any?>(this.o, this.s),
     arrayOf<Any?>(___other!!.o, ___other!!.s),
    )
   }

   override fun hashCode(): Int {
    return Arrays.hashCode(
     arrayOf<Any?>(this.o, this.s),
    )
   }

   override fun toString(): String {
    return Arrays.toString(
     arrayOf<Any?>(this.o, this.s),
    )
   }
  }
  val r: Any? = null
  var s2: String? = null
  when (r!!) {
   is R if run {
    val pattern___1R: R = r as R
    val exp: Any? = pattern___1R.o()
    exp is R && run {
     val pattern___1R_1: R = exp as R
     val exp_1: Any? = pattern___1R_1.o()
     exp_1 is String && run {
      val s1: String = exp_1 as String
      s2 = pattern___1R_1.s()
      val s3: String? = pattern___1R.s()
      s1.equals("Hello")
     }
    }
   } -> {
    s2!!.length
   }
   is R if run {
    val pattern___1R_2: R = r as R
    val c1: Any? = pattern___1R_2.o()
    val c2: String? = pattern___1R_2.s()
    true
   } -> {}
   else -> {}
  }
 }

 internal open fun testExhaustivePatternsWithNoDefault_pp_switchpatterns() {
  val o: Sealed? = null
  val i: Int = run {
   when (o!!) {
    is A if run {
     val a: A = o as A
     true
    } -> {
     return@run 1
    }
    is B if run {
     val b: B = o as B
     true
    } -> {
     return@run 2
    }
    else -> {
     throw AssertionError("Unreachable")
    }
   }
  }
 }

 internal open fun testPatternsWithNull_pp_switchpatterns() {
  val color: Color? = null
  when (color) {
   Color.RED -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   null -> {}
   else -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
  }
  when (color) {
   Color.RED -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   else -> {
    val variable: Int = 0
   }
  }
  when (Color.valueOf("BLUE")) {
   Color.RED -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   else -> {}
  }
  val digit: Digit? = null
  when (digit) {
   Digit.ZERO -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   null -> {}
   else -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
  }
  val s: String = "Hi"
  when (s) {
   "Hi" -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   null -> {}
   else -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
  }
  when (s) {
   "Hi" -> {
    SwitchPatterns.fail_pp_switchpatterns()
   }
   else -> {}
  }
 }

 companion object {
  @JvmStatic
  internal fun fail_pp_switchpatterns() {}
 }

 interface Sealed {
  class A: Sealed

  class B: Sealed
 }

 enum class Color {
  RED,
  BLUE,
  GREEN;
 }

 @JsEnum
 enum class Digit {
  ZERO,
  ONE,
  TWO,
  THREE;
 }
}
